package nl.tudelft.otsim.GeoObjects;

import java.awt.Color;
import java.awt.Polygon;
import java.awt.geom.GeneralPath;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Locale;
import java.util.SortedSet;
import java.util.TreeSet;

import nl.tudelft.otsim.FileIO.ParsedNode;
import nl.tudelft.otsim.FileIO.StaXWriter;
import nl.tudelft.otsim.FileIO.XML_IO;
import nl.tudelft.otsim.GUI.GraphicsPanel;
import nl.tudelft.otsim.GUI.InputValidator;
import nl.tudelft.otsim.GUI.Main;
import nl.tudelft.otsim.GeoObjects.PriorityConflict.conflictType;
import nl.tudelft.otsim.SpatialTools.Circle;
import nl.tudelft.otsim.SpatialTools.Curves;
import nl.tudelft.otsim.SpatialTools.Planar;

/**
 * This class encapsulates the data that is specific to a node.
 * 
 * @author Peter Knoppers & gtamminga
 */
public class Node extends Vertex implements XML_IO {
	/** Name for a Node element when stored in XML format */
	public static final String XMLTAG = "node";
	
	
	/** Name for a Node name element when stored in XML format */
	private static final String XML_NAME = "name";
	/** Name for a Node ID element when stored in XML format */
	private static final String XML_ID = "ID";
	
	private int nodeCount = 0;
	private String name = null;
    private int nodeID = -1;
    private boolean sink = false;
    private boolean source = false;
	private TreeSet<DirectionalLink> links = null;
	private ArrayList<Vertex> conflictArea = null;
	private ArrayList<ArrayList<Vertex>> closingLines = new ArrayList<ArrayList<Vertex>>();
	private TrafficLightController trafficLightController = null;
	private Network network;
	private Circle circle;
	private final boolean autoGenerated;

	/**
	 * Create a new Node.
	 * @param network {@link Network}; network to which the new Node belongs
	 * @param name String; name of the new Node
	 * @param X Double; X-Coordinate of the new Node
	 * @param Y Double; Y-Coordinate of the new Node
	 * @param Z Double; Z-Coordinate of the new Node
	 * @param autoGenerated Boolean; must be true for nodes created in junction expansion; false otherwise
	 */
    public Node (Network network, String name, double X, double Y, double Z, boolean autoGenerated) {
        super(X, Y, Z);
        this.name = name;
        this.nodeID = nodeCount;
        this.network = network;
        this.autoGenerated = autoGenerated;
    }
   
    /**
     * Create a new Node.
	 * @param network {@link Network}; network to which the new Node belongs
	 * @param name String; name of the new Node
     * @param nodeID Integer; to be depreciated
	 * @param X Double; X-Coordinate of the new Node
	 * @param Y Double; Y-Coordinate of the new Node
	 * @param Z Double; Z-Coordinate of the new Node
	 * @param autoGenerated Boolean; must be true for nodes created in junction expansion; false otherwise
     */
    public Node (Network network, String name, int nodeID, double X, double Y, double Z, boolean autoGenerated) {
    	this(network, name, X, Y, Z, autoGenerated);
        this.nodeID = nodeID;
    }
    
	/**
	 * Create a Node from a parsed XML file.
	 * @param network {@link Network}; the Network that will own the new Node
	 * @param pn {@link ParsedNode}; root of the Node field in the parsed XML file
	 * @throws Exception
	 */
    public Node(Network network, ParsedNode pn) throws Exception {
    	// Initialize everything to some invalid value
    	this.network = network;
    	autoGenerated = false;
    	x = y = z = Double.NaN;
		for (String fieldName : pn.getKeys()) {
			if (pn.size(fieldName) != 1)
				throw new Exception("Field " + fieldName + " has " + pn.size(fieldName) + "elements (should be 1)");
			if (fieldName.equals(TrafficLightController.XMLTAG)) {
				trafficLightController = new TrafficLightController(network, pn.getSubNode(TrafficLightController.XMLTAG, 0));
				continue;
			} 
			String value = pn.getSubNode(fieldName, 0).getValue();
			if (null == value)
				throw new Exception("Value of " + fieldName + " is null");
			if (fieldName.equals(XML_NAME))
				name = value;
			else if (fieldName.equals(XML_ID))
				nodeID = Integer.parseInt(value);
			else if (fieldName.equals(XML_X))
				x = Double.parseDouble(value);
			else if (fieldName.equals(XML_Y))
				y = Double.parseDouble(value);
			else if (fieldName.equals(XML_Z))
				z = Double.parseDouble(value);
			else
				throw new Exception("Unknown field in Node: \"" + fieldName + "\"");
		}
		if (null == name)
			throw new Exception("Node has no name " + pn.lineNumber + ", " + pn.columnNumber);
		if (-1 == nodeID)
			throw new Exception("Node has no ID " + pn.lineNumber + ", " + pn.columnNumber);
		if (Double.isNaN(x) || Double.isNaN(y))
			throw new Exception("Node has no valid X and/or Y " + pn.lineNumber + ", " + pn.columnNumber);
	}

	/**
     * Write this Node to an XML file.
     * @param staXWriter {@link StaXWriter}; writer for the XML file
     * @return Boolean; true on success; false on failure
     */
    @Override
	public boolean writeXML (StaXWriter staXWriter) {
		return staXWriter.writeNodeStart(XMLTAG)
				&& staXWriter.writeNode(XML_NAME, getName_r())
				&& staXWriter.writeNode(XML_ID, Integer.toString(getNodeID()))
				&& writeVertexXML(staXWriter)
				&& ((null == trafficLightController) || trafficLightController.writeXML(staXWriter))
				&& staXWriter.writeNodeEnd(XMLTAG);
    }
    
    /**
     * Retrieve the name of this Node.
     * @return String; the name of this Node
     */
    public String getName_r() {
		return name;
	}

    /**
     * Change the name of this Node.
     * @param nodeName String; new name for this Node
     */
	public void setName_w(String nodeName) {
		this.name = nodeName;
	}
	
	/**
	 * Checker for proposed name of a Node.
	 * @return InputValidator for Node name.
	 */
	public InputValidator validateName_v() {
		return new InputValidator(new InputValidator.CustomValidator() {
			@Override
			public boolean validate(String originalValue, String proposedValue) {
				if (! proposedValue.matches("[a-zA-Z_][-a-zA-Z0-9_.]*"))
					return false;	// not a decent name
				if (proposedValue.equals(originalValue))
					return true;	// current name is OK
				// Anything else must be unique among the node names
				return network.lookupNode(proposedValue, false) == null;
			}
		});
	}

	/**
	 * To be depreciated <br />
	 * Retrieve the ID of this Node.
	 * @return Integer; the numerical ID of this Node
	 */
	public int getNodeID() {
		return nodeID;
	}

	/**
	 * Delete all {@link DirectionalLink DirectionalLinks} of this Node.
	 */
	public void clearLinks() {
		links = new TreeSet<DirectionalLink>();
	}
	
	/**
	 * Add one {@link Link} to this Node.
	 * @param link {@link Link} link to add to this Node
	 * @param incoming Boolean; true if the Link points towards this Node;
	 * false if the Link points away from this Node
	 */
	public void addLink(Link link, boolean incoming) {
		links.add(new DirectionalLink(link, incoming));
	}
	
	/**
	 * Retrieve all {@link DirectionalLink DirectionalLinks} of this Node.
	 * @return TreeSet&lt;{@link DirectionalLink}&gt; the set of directional
	 * links of this Node
	 */
	public final TreeSet<DirectionalLink> getDirectionalLinks() {
		return links; 
	}
	
	/**
	 * Retrieve all {@link Link Links} of this Node.
	 * @return ArrayList&lt;{@link Link}&gt; set of Links of this Node
	 */
	public ArrayList<Link> getLinks_r () {
		ArrayList<Link> result = new ArrayList<Link>();
		if (null == links) {
			System.err.println("getLinks_r: links is null!");
			return result;
		}
		for (DirectionalLink dl : links)
			result.add(dl.link);
		return result;
	}
	
	/**
	 * Report weather this Node is a sink (has only incoming Links). 
	 * @return Boolean; true if this Node is a sink. false if this Node is not
	 * a sink
	 */
	public boolean isSink() {
		return sink;
	}

	/**
	 * Report weather this Node is a source (has only outgoing Links).
	 * @return Boolean; true if this Node is a source; false if this Node is
	 * not a source
	 */
	public boolean isSource() {
		return source;
	}

	/**
	 * Retrieve the {@link nl.tudelft.otsim.SpatialTools.Circle} that indicates the extent of this Node.
	 * @return {@link nl.tudelft.otsim.SpatialTools.Circle}; circle that indicates the extent of this Node.
	 */
	public final Circle getCircle() {
		return circle;
	}
	
	@Override
	public String toString() {
		return String.format(Main.locale, "%s ID=%d (%.2fm, %.2fm, %.2fm)", name, nodeID, getX(), getY(), getZ());
	}
	
	/**
	 * This class combines a {@link Link}, angle and direction into one object.
	 * 
	 * @author Peter Knoppers
	 */
	public class DirectionalLink implements Comparable<DirectionalLink> {
		public Link link;
		double angle;
		boolean incoming;

		/**
		 * Create a DirectionalLink.
		 * @param link {@link Link} link of the new DirectionalLink
		 * @param incoming Boolean; must be true if the {@link Link} points 
		 * into the {@link Node} that will own this DirectionalLink; must be 
		 * false if the Link points away from the {@link Node} that will own
		 * this DirectionalLink 
		 */
		public DirectionalLink(Link link, boolean incoming) {
			this.link = link;
			this.incoming = incoming;
			ArrayList<Vertex> vertices = link.getVertices();
			Point2D.Double p0 = vertices.get(incoming ? vertices.size() - 1 : 0).getPoint();
			Point2D.Double p1 = vertices.get(incoming ? vertices.size() - 2 : 1).getPoint();
			angle = Math.atan2(p1.y - p0.y, p1.x - p0.x);
			if (angle < 0)
				angle += 2 * Math.PI;
			if (angle >= 2 * Math.PI)
				angle -= 2 * Math.PI;
		}
		
		@Override
		public String toString() {
			return String.format("link %s, angle %.0f, %s", link.getName_r(), angle * 180 / Math.PI, incoming ? "incoming" : "outgoing");
		}
		
		@Override
		public int compareTo(DirectionalLink other) {
			// return +1 if this must be sorted after other; etc.
			if (angle == other.angle) {
				if (incoming == other.incoming)
					return 0;
				else if (incoming)
					return 1;
				return -1;
			}
			else if (angle > other.angle)
				return 1;
			return -1;
		}
		
	}

	final double veryClose = 0.0001;
	
	/**
	 * Compute the boundary of the area that all connections for this Node
	 * occupy. Both the circle and the convex hull of the conflictArea are
	 * computed.
	 * @param drivable Boolean; if true only drive-able CrossSectionElements
	 * are taken into account; if false, all CrossSectionElements are used.
	 */
	public void determineNodeBoundary(boolean drivable) {
		//System.out.println("Determine node boundary of " + name);
		ArrayList<Point2D.Double> pointCloud = new ArrayList<Point2D.Double>(); 
		// Add all end points of (drive-able) crossSectionElements to the pointCloud
		for (DirectionalLink dl : links) {
			CrossSection cs = dl.link.getCrossSectionAtNode(dl.incoming);
			for (int index = 2 * cs.getCrossSectionElementList_r().size(); --index >= 0; ) {
				if ((! drivable) || cs.elementFromNode(dl.incoming, true, index).getCrossSectionElementTypology().getDrivable()) {
					Line2D.Double dlLine = cs.vectorAtNode(dl.incoming, true, index, false);
					if (null == dlLine)
						continue;
					pointCloud.add((Point2D.Double) dlLine.getP1());
					for (DirectionalLink otherDL : links) {
						if (otherDL.angle >= dl.angle) // only search up to dl (and NEVER include dl itself)
							break;	// this way we'll find each intersection only ONCE
						CrossSection otherCS = otherDL.link.getCrossSectionAtNode(otherDL.incoming);
						for (int otherIndex = 2 * otherCS.getCrossSectionElementList_r().size(); --otherIndex >= 0; ) {
							if ((! drivable) || (otherCS.elementFromNode(otherDL.incoming, true, otherIndex).getCrossSectionElementTypology().getDrivable())) {
								Line2D.Double otherDLLine = otherCS.vectorAtNode(otherDL.incoming, true, otherIndex, false);
								if (null == otherDLLine)
									continue;
								if (Planar.lineSegmentIntersectsLineSegment(dlLine, otherDLLine))
									pointCloud.add(Planar.intersection(dlLine, otherDLLine));
							}
						}
					}
				}
			}
		}

		//System.out.println("pointCloud of " + name + " contains these points: " + pointCloud.toString());
		if (0 == pointCloud.size())
			pointCloud.add(getPoint());	// add design point of this node
		circle = Planar.circleCoveringPoints(pointCloud);
		//System.out.format("covering circle is %s\r\n", circle.toString());
		// Create the convex hull consisting of the points where the drive-able parts of the links enter the covering circle
		ArrayList<Point2D.Double> points = new ArrayList<Point2D.Double>();
		for (DirectionalLink dl : links) {
			CrossSection cs = dl.link.getCrossSectionAtNode(dl.incoming);
			for (int index = 2 * cs.getCrossSectionElementList_r().size(); --index >= 0; )
				if (cs.elementFromNode(dl.incoming, true, index).getCrossSectionElementTypology().getDrivable()) {
					Line2D.Double line = cs.vectorAtNode(dl.incoming, true, index, false);
					if (null == line)
						continue;
					Point2D.Double intersections[] = Planar.intersectLineSegmentAndCircle(line, circle);
					//System.out.format(Main.Locale, "line %s intersects circle %s at %d point(s)\r\n", GeometryTools.Line2DToString(line), circle.toString(), intersections.length);
					if (intersections.length > 1) {
						System.err.println("Peter thinks this never happens...");
						// use the one that is closest to the far end of the line
						if (intersections[0].distance(line.getP2()) < intersections[1].distance(line.getP2()))
							points.add(intersections[0]);
						else
							points.add(intersections[1]);
					}
					else if (intersections.length > 0)
						points.add(intersections[0]);
					else {
						System.out.println("line " + Planar.Line2DToString(line) + " does not intersect the circle " + circle.toString());
						// probably a very near miss
						double ratio = circle.radius() / line.getP1().distance(circle.center());
						if ((ratio > 0.99) && (ratio < 1.01))
							points.add(Planar.logPoint("adding almost intersection", (Point2D.Double)(line.getP1())));
						else
							System.err.println("Total miss: ratio is " + ratio + " (" + circle.radius() / line.getP2().distance(circle.center()) + ")");
					}
				}
		}
		if (points.size() == 0)
			return;
		// Compute the convex hull (in 2D) and convert that into an ArrayList<Vertex>
		//System.out.println("Computing convex hull of " + points.toString());
		conflictArea = new ArrayList<Vertex>();
		for (Point2D.Double p : Planar.convexHull(points))
			conflictArea.add(new Vertex(p, z));	// use Z-component of this node
		conflictArea.add(conflictArea.get(0));	// close the polygon
		//System.out.println("convex hull is " + conflictArea.toString());
	}
	
	private ArrayList<Vertex> truncateHeadAtConflictArea(ArrayList<Vertex> vertices) {
		// Generate the polygon of the conflictArea
		Point2D.Double polygon[] = new Point2D.Double[conflictArea.size()];
		for (int i = conflictArea.size(); --i >= 0; )
			polygon[i] = conflictArea.get(i).getPoint();
		ArrayList<Vertex> result = new ArrayList<Vertex>();
		result.add(vertices.get(0));
		Point2D.Double prevPoint = null;
		int numberOfReplacedVertices = 0;
		for (Vertex v : vertices) {
			Point2D.Double p = v.getPoint();
			if (null != prevPoint) {
				Line2D.Double line = new Line2D.Double(prevPoint, p);
				double closest = Double.MAX_VALUE;
				Point2D.Double replacementPoint = null;
				ArrayList<Point2D.Double> intersections = Planar.lineIntersectsPolygon(line, polygon);
				// find intersections with the polygon
				for (Point2D.Double intersection : intersections) {
					// if statement added 
					if (intersection != null) {
						double distance = intersection.distance(p);
						if (distance < closest) {
							replacementPoint = intersection;
							closest = distance;
						}
					}
				}
				// find very near misses with the polygon
				for (Point2D.Double pp : polygon) {
					if (Planar.distanceLineSegmentToPoint(line, pp) < veryClose) {
						double distance = pp.distance(p);
						if (distance < closest) {
							replacementPoint = pp;
							closest = distance;
						}
							
					}
				}
				if (null != replacementPoint && numberOfReplacedVertices == 0) {
					numberOfReplacedVertices++;						
					result.clear();
					result.add(new Vertex(replacementPoint, z));
				}
				// 20140120/PK: WRONG: else	(must ALWAYS add vertex v)
				result.add(v);
			}
			prevPoint = p;
		}		
		if (result.size() < 2) {
			System.err.println("Malformed vertices");
			System.out.println("vertices are:" + Planar.verticesToString(vertices));
			System.out.println("polygon is:  " + Planar.pointsToString(polygon));
			// Uncomment to try again for debugging
			//truncateHeadAtConflictArea(vertices);
		}
		return result;
	}
	
	/**
	 * Truncate a list of {@link Vertex Vertices} at the conflict area of this
	 * Node. The provided list is modified.
	 * @param vertices ArrayList&lt;{@link Vertex}&gt;; the vertices to
	 * truncate
	 * @return ArrayList&lt;{$link Vertex}&gt; the modified list of vertices
	 */
	public ArrayList<Vertex> truncateAtConflictArea(ArrayList<Vertex> vertices) {
		if (vertices.size() < 2)
			throw new Error("Malformed vertices");
		if (! hasConflictArea())
			return vertices;	// First take care of the easy cases	
		
		double distanceStart = vertices.get(0).getPoint().distance(circle.center());
		double distanceEnd = vertices.get(vertices.size() - 1).getPoint().distance(circle.center());
		if ((distanceStart < circle.radius()) && (distanceEnd < circle.radius())) {
			System.err.println("Vertices begin AND end within circle of node " + name);
			return vertices;
		} 
		if (distanceStart < circle.radius()) {
			vertices = truncateHeadAtConflictArea(vertices);
			if (vertices.size() < 2)
				throw new Error("Malformed vertices");
			return vertices;
		}
		if (distanceEnd < circle.radius()) {
			// This severely clobbers the provided list of vertices
			// We'd better make sure that the caller does not mind...
			Collections.reverse(vertices);
			vertices = truncateHeadAtConflictArea(vertices);
			if (vertices.size() < 2)
				throw new Error("Malformed vertices");
			Collections.reverse(vertices);
			return vertices;
		}
		// Neither end of vertices is near the conflict area
		return vertices;
	}
	
	/**
	 * Fix the geometry of this Node. This method must be called when something 
	 * in the {@link Network} (or at least in any the {@link Link Links} 
	 * starting or ending at this Node has changed. 
	 */
	public void fixGeometry () {
		//System.out.println(String.format("Entering fixGeometry: Directional links at node %d (%s) %s", nodeID, toString(), links.toString()));
		//conflictArea = null;
		closingLines = new ArrayList<ArrayList<Vertex>>();
		if (links.size() <= 1) {
			//System.out.println("Returning from fixGeometry because links.size is " + links.size() + " which is <= 1");
			return;	// that was the really easy case
		}
		DirectionalLink prevDL = links.last();
		for (DirectionalLink dl : links) {
			boolean prevIncoming = prevDL.incoming;
			boolean thisIncoming = dl.incoming;
			CrossSection prevCS = prevDL.link.getCrossSectionAtNode(prevIncoming);
			CrossSection thisCS = dl.link.getCrossSectionAtNode(thisIncoming);
			//System.out.println(String.format("prevCS (%s) %s", prevIncoming ? "incoming" : "outgoing", prevCS.toString()));
			//System.out.println(String.format("thisCS (%s) %s", thisIncoming ? "incoming" : "outgoing", thisCS.toString()));
			// Connect the CrossSectionElements of dl to the corresponding CrossSectionElements of prevDL
			// Stop after the first boundary of a drivable element is done, or at the before-last CrossSectionElement
			// FIXME: this will fail if there is more than one drivable element.
			// But I haven't figured out how that case should be handled anyway...
			// FIXME: this also fails if (almost) parallel links meet at the node.
			int thisCSEIndex = 0;
			int thisLastCSEIndex = thisCS.getCrossSectionElementList_r().size() * 2 - 1;
			int prevCSEIndex = 0;
			int prevLastCSEIndex = prevCS.getCrossSectionElementList_r().size() * 2 - 1;
			while ((thisCSEIndex != thisLastCSEIndex) && (prevCSEIndex != prevLastCSEIndex)) {
				CrossSectionElementTypology prevTypology = prevCS.elementFromNode(prevIncoming, true, prevCSEIndex).getCrossSectionElementTypology();
				CrossSectionElementTypology thisTypology = thisCS.elementFromNode(thisIncoming, false, thisCSEIndex).getCrossSectionElementTypology();
				//System.out.println(String.format("prevCSEIndex=%d (%s), thisCSEIndex=%d (%s)", prevCSEIndex, prevTypology.getName_r(), thisCSEIndex, thisTypology.getName_r()));
				if (! prevTypology.getName_r().equals(thisTypology.getName_r())) {
					// CrossSectionElement is of a different type
					if (! (prevTypology.getDrivable() && thisTypology.getDrivable())) {
						// And not both are drive-able
						if (prevTypology.getDrivable())
							thisCSEIndex++;
						else if (thisTypology.getDrivable())
							prevCSEIndex++;
						// Both are not drive-able; skip the narrowest
						else if (prevCS.elementFromNode(prevIncoming, true, prevCSEIndex).getCrossSectionElementWidth() < thisCS.elementFromNode(thisIncoming, true, thisCSEIndex).getCrossSectionElementWidth())
							prevCSEIndex++;
						else
							thisCSEIndex++;
						continue;						
					}
					// Both are drive-able (but not of the same type)
				}
				// Connect two adjacent drive-able CrossSectionElements
				Line2D.Double prevVector = prevCS.vectorAtNode(prevIncoming, true, prevCSEIndex, true);
				if (null != prevVector) {
					//System.out.println(String.format("prevVector %s", line2D2String(prevVector)));
					Line2D.Double thisVector = thisCS.vectorAtNode(thisIncoming, false, thisCSEIndex, true);
					if (null != thisVector) {
						//System.out.println(String.format("thisVector %s", line2D2String(thisVector)));
						Point2D.Double intersection = Planar.intersection(prevVector, thisVector);
						// Remark: what happens at junctions with sharp bends (in and out)?
						if (null == intersection)
							System.out.println("Node-Geometry: intersection is null!");
						//else if (GeometryTools.distanceLineSegmentToPoint(thisVector, intersection) > tooFar) {
						//	System.out.println("intersection is too far away: " + GeometryTools.distanceLineSegmentToPoint(thisVector, intersection) + "m");
						//} 
						else {
							//System.out.println(String.format("Intersection %s", intersection.toString()));
							if (intersection.distance(circle.center()) > circle.radius())
								System.out.println("Intersection lies outside AOI");
							//Vertex endPoint = new Vertex(intersection.x, intersection.y, 0);
							//prevCS.setEndPoint(prevIncoming, true, prevCSEIndex, endPoint);
							//thisCS.setEndPoint(thisIncoming, false, thisCSEIndex, endPoint);
						}
					}
					thisCSEIndex++;
				}
				prevCSEIndex++;
				if (prevTypology.getDrivable())
					break;
			}			
			//System.out.println("Done one link pair");
			prevDL = dl;
		}
		SortedSet<Integer> sortedPriorities = new TreeSet<Integer>();
		for (DirectionalLink dl : links) {
			CrossSection cs = dl.link.getCrossSectionAtNode(dl.incoming);
			for (CrossSectionElement cse : cs.getCrossSectionElementList_r())
				sortedPriorities.add(cse.getCrossSectionElementTypology().getCouplingPriority());
		}
		//System.out.println("Returning from fixGeometry; Done node " + name);
	}
	
	/**
	 * Add boundary lines to fence off holes between adjacent drive-able
	 * {@link CrossSectionElement CrossSectionElements} that meet at this Node.
	 */
	public void closeHoles() {
		int dlIndex = 0;
		for (DirectionalLink dl : links) {
			CrossSection cs = dl.link.getCrossSectionAtNode(dl.incoming);
			// find the right boundary of a drive-able CrossSectionElement
			for (int index = 1; index < 2 * cs.getCrossSectionElementList_r().size(); index += 2) {
				CrossSectionElement cse = cs.elementFromNode(dl.incoming, false, index);
				if (! cse.getCrossSectionElementTypology().getDrivable())
					continue;
				// Find the left boundary of the next drive-able CrossSectionElement
				DirectionalLink otherDL = dl;
				int otherDLIndex = dlIndex; 
				int otherIndex = index + 1;
				while (true) {
					CrossSection otherCS = otherDL.link.getCrossSectionAtNode(otherDL.incoming);
					boolean foundIt = false;
					for ( ; otherIndex < 2 * otherCS.getCrossSectionElementList_r().size(); otherIndex += 2) {
						CrossSectionElement otherCSE = otherCS.elementFromNode(otherDL.incoming, false, otherIndex);
						if (otherCSE.getCrossSectionElementTypology().getDrivable()) {
							foundIt = true;
							break;
						}
					}
					if (foundIt) {
						Vertex fromVertex = cs.vertexFromNode(dl.incoming, false, index, 0, true);
						Vertex toVertex = otherCS.vertexFromNode(otherDL.incoming, false, otherIndex, 0, true);
						if ((null == fromVertex) || (null == toVertex))
							System.err.println("null vertex in closeHoles");
						else if (fromVertex.getPoint().distance(toVertex.getPoint()) > veryClose) {
							System.out.println(String.format("Missing link from %s to %s index=%d, otherIndex=%d", fromVertex.toString(), toVertex.toString(), index, otherIndex));
							ArrayList<Vertex> closingLine = new ArrayList<Vertex>();
							closingLine.add(new Vertex(fromVertex));
							closingLine.add(new Vertex(toVertex));
							closingLines.add(closingLine);
						}
						break;
					}
					// search for a drive-able CrossSectionElement in the next link
					//System.out.println("searching the next link");
					if (++otherIndex >= 2 * otherCS.getCrossSectionElementList_r().size()/*links.size()*/) {
						otherIndex = 0;
						otherDLIndex++;
						if (otherDLIndex >= links.size())
							otherDLIndex = 0;
						otherDL = (DirectionalLink) links.toArray()[otherDLIndex];
					} else
						System.out.println("Cannot happen???");
				}					
			}
			dlIndex++;
		}
	}
	
	private int directionalCount(boolean in) {
		int result = 0;
		for (DirectionalLink dl : links)
			if (dl.incoming == in)
				result++;
		return result;
	}
	
	/**
	 * Determine the number of incoming {@link Link Links} at this Node.
	 * @return Integer; the number of incoming {@link Link Links} at this Node
	 */
	public int incomingCount() {
		return directionalCount(true);
	}
	
	/**
	 * Determine the number of departing {@link Link Links} at this Node.
	 * @return Integer; the number of departing {@link Link Links} at this Node
	 */
	public int leavingCount() {
		return directionalCount(false);
	}
	
	private ArrayList<DirectionalLink> getLinks() {
		ArrayList<DirectionalLink> result = new ArrayList<DirectionalLink> ();
		if (null == links) {
			System.err.println("Links is null (this is node " + toString() + ")");
			return result;
		}
		for (DirectionalLink dl : links)
			result.add(dl);
		return result;
	}
	
    private void determineSinkOrSource() {
    	sink = false;
    	source = false;
    	int inCount = incomingCount();
    	int outCount = leavingCount();
    	// Take care of the easy cases first
    	if ((outCount == 0) && (inCount == 0))
    		return;	// we don't label unconnected nodes as source or sink
    	else if ((outCount == 0) && (inCount > 0))
    		sink = true;
    	else if((outCount > 0) && (inCount == 0))
    		source = true;
    	else if ((inCount > 1) || (outCount > 1))
    		return;
    	else {
	    	// This node has at precisely one incoming and one outgoing link
    		// If both connect to the same other node, this node is BOTH a
    		// source AND a sink
	    	ArrayList<DirectionalLink> dlList = getLinks();
			int incomingIndex = dlList.get(0).incoming ? 0 : 1;  
			int leavingIndex = 1 - incomingIndex;
			if (dlList.get(incomingIndex).link.getFromNode_r().equals(dlList.get(leavingIndex).link.getToNode_r()))
				sink = source = true;  
    	}
    }
    
    
    
    private class OutLaneInfo {
    	private Lane outLane;
    	private int linkRank;
    	private double angleDifference;
    	private Lane inLane;
    	
    	private OutLaneInfo(Lane outLane, Double angleDifference, int linkRank)  {
    		this.outLane = outLane;
    		this.linkRank = linkRank;
    		this.angleDifference = angleDifference;
    	}
    	
		public Lane getLane() {
			return outLane;
		}
		
		public int getLinkRank() {
			return linkRank;
		}
		
		public double getAngleDifference() {
			return angleDifference;
		}

		public Lane getInLane() {
			return inLane;
		}
		public void setInLane(Lane inLane) {
			this.inLane = inLane;
		}	

    }
		public enum Turn {RIGHT_UTURN, RIGHT_SHARP, RIGHT, STRAIGHT, LEFT, LEFT_SHARP, LEFT_UTURN};	
		
	    private class OutLinkInfo {
	    	private ArrayList<Lane> outLanes;
	    	private double angleDifference;
	    	private int linkRank;
			private int turnIndex;
			private int numberOfLanes;	
			private String turnName;
			private boolean startRight;
			private boolean UTurn = false;
		
	    	private OutLinkInfo(ArrayList<Lane> outLanes, Double angleDifference, int linkRank)  {
	    		this.outLanes = outLanes;
	    		this.linkRank = linkRank;
	    		this.angleDifference = angleDifference;
	    		turnType(angleDifference, linkRank);
	    		this.numberOfLanes = outLanes.size();
	    	}    	
			public void turnType(double angleDif, int linkRank) {
				int index = 0;
	    		final double uTurnRight = 0.10 * Math.PI;
	    		final double sharpRight = 0.25 * Math.PI;
	    		final double right = 0.75 * Math.PI;
	    		final double straight = 1.25 * Math.PI;
	    		final double left = 1.75 * Math.PI;
	    		final double sharpLeft = 1.90 * Math.PI;

	    		if ( angleDif < uTurnRight && linkRank == 0) {
					index = 0;
					UTurn = true;
	    		}
				else if ( angleDif >= uTurnRight  && angleDif <= sharpRight )
					index = 1;
				else if ( angleDif >= sharpRight  && angleDif <= right )
					index = 2;
				else if ( angleDif >= right  && angleDif <= straight )
					index = 3;
				else if ( angleDif >= straight  && angleDif <= left )
					index = 4;
				else if ( angleDif >= left  && angleDif <= sharpLeft )
					index = 5;
				// only the last arm can be a U-turn
				else if ( (angleDif > sharpLeft || angleDif < uTurnRight) && linkRank > 0) {
					index = 6;	
					UTurn = true;
					if (angleDif != 0)
						index = 6;
				}
				
				this.turnIndex= index;
				Turn[] turns = Turn.values();
				this.turnName = turns[turnIndex].toString();
				if (index <= Turn.STRAIGHT.ordinal())
					startRight = true;
				else
					startRight = false;
				
			}	 
			
			public String getName()  {
				return turnName;
			}	    			
			public int getIndex()  {
				return turnIndex;
			}

			public ArrayList<Lane> getOutLanes() {
				return outLanes;
			}
			
			public int getLinkRank() {
				return linkRank;
			}
			
			public int getNumberOfLanes() {
				return numberOfLanes;
			}


			public double getAngleDifference() {
				return angleDifference;
			}

			public boolean isStartRight() {
				return startRight;
			}

			public boolean isUTurn() {
				return UTurn;
			}

	    }
	    
	    private class LaneConnect {
	    	private Lane inLane;
			private Lane outLane;
			private int linkRank; 

			private LaneConnect(Lane inlane, Lane outLane, int linkRank)  {
	    		this.inLane = inlane;
	    		this.outLane = outLane;
	    		this.linkRank = linkRank;
	    	}
			
			public Lane getInLane() {
				return inLane;
			}

			public Lane getOutLane() {
				return outLane;
			}

			public int getLinkRank() {
				return linkRank;
			}
			
    }

    /**
     * Return a list of {@link DirectionalLink DirectionalLinks} of this Node.
     * @return ArrayList&lt;{@link DirectionalLink}&gt;; the list of DirectionalLinks of this Node 
     */
	public ArrayList<DirectionalLink> getLinksFromJunction() {
	    determineSinkOrSource();	// FIXME: is this call needed?
		return getLinks();
	}
	
    /**
     * Connect the {@link Link Links} at this Node.
     */
    public void fixLinkConnections() {
    	ArrayList<DirectionalLink> dlList = getLinksFromJunction();
		int inCount = incomingCount();
		int outCount = leavingCount();

		// Create junction expansion
		// At junctions every entering link and every exiting link receives a new node
		// This new node replaces the original one, and gets the coordinates of the driving lane
		// At the junctions, new turning links are created by generating links between the new nodes 
		// These links receive  a new crossSection, and one crossSection element: the road with road markings and
		// finally driving lanes
		// FIXME: assumes that all turns are permitted (should be dependent on road markings, signs, etc.
		// TODO Later on: these turning lanes will only be generated if turning arrows show if a turn exists

		ArrayList<Link> newLinks = new ArrayList<Link>();
		// we only expand nodes if there really is a junction 
		final boolean uTurnAllowed = false;
		final boolean laneSharing = true;
		if ((inCount >= 1) && (outCount >= 1) && (inCount + outCount > 2)) {
			// Expand nodes and create a junction with new turning links that connect arms of a junction
			int incomingArm = -1; // index of the incoming arm: start at minus one

			// Block A
			// for every incoming arm we create the turning movements
			for (DirectionalLink incoming : dlList) {
				incomingArm++;
				if (! incoming.incoming)
					continue;
				// for the incoming lanes: detect the turning movements and create turning lanes
				// if turning arrows are provided: connect lanes/links accordingly
				// else an automated search: uses some logic to define turning movements from one link/lane to another 

				// firstly, select the lanes from the incoming link into the junction
	    		int size = incoming.link.getCrossSections_r().size();
	    		// collect all entering lanes from one link
	    		ArrayList<Lane> inLanesAll = incoming.link.getCrossSections_r().get(size - 1).collectLanesReversed();
	    		
	            //step through the leaving links and collect information for all leaving lanes
	    		// the OutLaneInfo object is created to collect that information and use it later on
	    		ArrayList<OutLinkInfo> outLanesAndLinkList = new ArrayList<OutLinkInfo>() ;
	    		ArrayList<LaneConnect> connectedLanesList = new ArrayList<LaneConnect>() ;
	    		
	    		// determine the angle between the entering and leaving link
	    		// the angle is represented in radians. Starting at west (0) and going anti-clockwise.
	    		// So north is around 4.5, east = pi, south = 1.5
	    		int nextArm = 0;
	    		int linkRank = 0;
	    		/* linkRank: rank of the leaving links counted in anti-clockwise order
	    		 * (in case of a 4-arm junction:
	    		 *    right lane = 0, 
	    		 *    straight = 1
	    		 *    left = 2
	    		 *    U-turn = 3)*/ 
	    		//
	    		//STEP 1: explore all leaving arms and save the info 
	    		// (OutLaneInfo: lane, angledif, linkRank)
	    		// 
				nextArm = incomingArm;	
				int numberOfLeavingLanes = 0;
				int numberOfIncomingArms = 1;
				int numberOfleavingArms = 0;
				boolean isUturn = false;
	    		for (int arm = 1; arm < dlList.size(); arm++) {
	    			nextArm++;
					// explore all links excluding the current incoming arm
					if (nextArm >= dlList.size())
						nextArm = 0;
	    			DirectionalLink leaving = dlList.get(nextArm);
					double angleDif;
					// if this is a leaving link:
					if (leaving.incoming)
						// determine if this link is from the opposite direction and if this is a real junction or not
						numberOfIncomingArms++;
					else {   					
						//compute the angle in radians between the incoming and leaving link
						numberOfleavingArms++;
		    			if (incoming.angle > leaving.angle)
	        				angleDif = 2 * Math.PI - incoming.angle + leaving.angle ;
	        			else
	        				angleDif = leaving.angle - incoming.angle;
	    	    		CrossSection outCs = leaving.link.getCrossSections_r().get(0);
    	    			// collect information on the index of the leaving link, its lanes and 
    	    			// the angle with the entering lane
	    	    		OutLinkInfo outLink = new OutLinkInfo(outCs.collectLanesReversed(), angleDif, linkRank);
        				if (outLink.isUTurn()) {
            				if (! uTurnAllowed)  {
            					isUturn = true;
        	    	    		continue;	            					
            				}
        				}
    	    	    	outLanesAndLinkList.add(outLink);	
	    	    		numberOfLeavingLanes = numberOfLeavingLanes + outCs.collectLanesReversed().size();
	    	    		// fill the type of bend
	    	    		//increase the index of the leaving link 
	    	    		linkRank++;
					}	    			
	    		}
				
	    		// determine if there is a real junction:
	    		// in case of four arms with two incoming and two leaving links
	    		// if there is a U-Turn it might be just a two link - two directions situation
	    		nextArm = incomingArm;
	    		boolean junction = false;
	    		if (outLanesAndLinkList.size() > 0 && numberOfIncomingArms == 2 && numberOfleavingArms == 2) {
	    			if (isUturn) {
	    				for (int arm = 1; arm < dlList.size(); arm++) {
	    	    			nextArm++;
	    					// explore all links excluding the current incoming arm
	    					if (nextArm >= dlList.size())
	    						nextArm = 0;
	    	    			DirectionalLink leaving = dlList.get(nextArm);
	    	    			if (leaving.incoming) {
	    	    				OutLinkInfo currentOutlinkInfo = outLanesAndLinkList.get(0);
	    	    				if (currentOutlinkInfo.getOutLanes().get(0).getCse().getCrossSection().getLink().getToNode_r().equals(leaving.link.getFromNode_r()))
	    	    					junction = false;
	    	    			}
	    				}
	    			}
	    			else 
	    				junction = true;
	    		}
	    		// a junction requires at least three links and one leaving link
	    		else if (outLanesAndLinkList.size() > 0 && (numberOfIncomingArms + outLanesAndLinkList.size()) > 2) {
	    			junction = true;
	    		}

				int numberOfLeavingLinks = linkRank;
        		ArrayList<RoadMarkerAlong> rmaList = new ArrayList<RoadMarkerAlong>();
				//  only if we do have a junction we perform step 2 and 3
    			////if (junction) {
        		if ((outLanesAndLinkList.size() > 0) && ((numberOfIncomingArms + outLanesAndLinkList.size()) > 2)) {
					// STEP 2: determine the turning movements

		    		// STEP 2A
        			// if turning movements are defined, the new turning lanes are constructed accordingly
		    		// the OutlinkNumber defines the arm(s) (in anti-clockwise order) that this lane connects to
		    		// could be "1" (first) or "12" (could be shared right/straight or right/right2 or right/left)
	    			if (inLanesAll.get(0).getTurnArrow().getOutLinkNumbers() != null)  { 
			    		// loop through the lanes of the entering link
			    		// sometimes a lane needs to be connected more than once (more turning movements per lane)
			    		// in that case the index is reset minus 1
			    		int turnCount = 0;
						int outLinkIndex = 0;
	            		for (int indexInlane = 0; indexInlane < inLanesAll.size(); indexInlane++) {
	            			// We start with the right turn
				    		Lane currentInLane = inLanesAll.get(indexInlane);
            				// retrieve the index of the outgoing links (one by one)
            				int outLinkRank = inLanesAll.get(indexInlane).getTurnArrow().getOutLinkNumbers()[turnCount];
            				// we look for the connecting outLane by looping through all outlanes at this node
            				OutLinkInfo currentOutlinkInfo = outLanesAndLinkList.get(outLinkIndex);
            				// connect to the lane of a leaving arm
            				// find the index of the correct outgoing link first
							while (outLinkRank != currentOutlinkInfo.getLinkRank()) {
								if (outLinkIndex >= 0) {
									if (outLinkRank < currentOutlinkInfo.getLinkRank())
										outLinkIndex--;
									else
										outLinkIndex++;
								}
								// retrieve the index of the current outlane
								if (outLinkIndex >= outLanesAndLinkList.size())
									break;
								if (outLinkIndex < 0)
									System.out.println("strange: less than zero");
								currentOutlinkInfo = outLanesAndLinkList.get(outLinkIndex);
							}
							// for an inlane, all outlanes of the corresponding outLink are checked:
							int inLanesToConnect = 1;
							// find the number of lanes with the same turning direction
							while (indexInlane + inLanesToConnect < inLanesAll.size()) {										
								if (inLanesAll.get(indexInlane + inLanesToConnect).getTurnArrow().getOutLinkNumbers()[0] == outLinkRank)  {
									break;
								}
								inLanesToConnect++;
							}
							for (int i = 0; i < inLanesToConnect; i++) {
								Lane outLane = currentOutlinkInfo.getOutLanes().get(i);
								// if a lane has got no stopLine (no priority defined) an "empty"  stopLine is added
					    		if (currentInLane.getStopLine() == null) {
					    			StopLine stopLine = new StopLine(currentInLane.getCse(), StopLine.NOSTOPLINE,-4.0, 2.0, 0.0); 
					    			currentInLane.setStopLine(stopLine);
					    		}
					    		currentInLane = inLanesAll.get(indexInlane);
								LaneConnect laneConnect = new LaneConnect(currentInLane, outLane, currentOutlinkInfo.getLinkRank());
								connectedLanesList.add(laneConnect);
					    		indexInlane++;
							}
/*							if (currentOutlinkInfo.getInLane() == null)
								System.out.println("strange: no inLane");*/
							
							// connect the inlane to the outlane
							// later on we will loop through the outLanesAndLinkList to generate new junction connectors 
							// but first continue to inspect the other in lanes and their turns!
            				// if more than one turning movement from an incoming lane?
            				// keep this lane at the next loop (until all turns are dealt with)
            				turnCount++; 
            				if (turnCount < inLanesAll.get(indexInlane).getTurnArrow().getOutLinkNumbers().length)  {
            					indexInlane--;
            				} else // go to the next inLane and reset turncount to zero
            					turnCount = 0;
            				outLinkIndex = 0;
	            		}
		    		}
            			
		    		// STEP 2B
		    		// if no turning movements are defined for this link/lane, 
		    		// construct the movements with some pre defined rules
	    			if (inLanesAll.get(0).getTurnArrow().getOutLinkNumbers() == null)  { 
        				Lane currentOutLane = null;

        				// explore all turns of the junction from this incoming arm
        				// we start with outLinkIndex 0 (first right going arm)
        				// all possible turning movements are explored
        				double[] shareOfLanes = new double[numberOfLeavingLinks];
        				int[] ceilShareOfLanes = new int[numberOfLeavingLinks];
        				int[] shareLaneNextMovement = new int[numberOfLeavingLinks];
        				int[] priorityShare = new int[numberOfLeavingLinks];
        				int mergeLanes = 0;
        				double[] exitLanes = new double[numberOfLeavingLinks];
        				boolean uTurn[] =  new boolean[numberOfLeavingLinks];        				 
        				int numberOfTurnLanes = inLanesAll.size();
        				int sumCeil = 0;
        				
        				for (int outLink = 0; outLink < numberOfLeavingLinks; outLink++)  {
	    					int outLaneIndex = 0;  		// the index of the lane on this exit-Link (count starts 
	                       	// from the outer-lane)
							Lane currentInLane = null;
	        				OutLinkInfo currentOutLinkInfo = outLanesAndLinkList.get(outLink);
	        				if (currentOutLinkInfo.getIndex() == Turn.LEFT_UTURN.ordinal() )
	        					priorityShare[outLink] = 0;
	        				else if (currentOutLinkInfo.getIndex() == Turn.RIGHT_UTURN.ordinal() )
	        					priorityShare[outLink] = 0;
	        				else if (currentOutLinkInfo.getIndex() == Turn.RIGHT_SHARP.ordinal() )
	        					priorityShare[outLink] = 1;
	        				else if (currentOutLinkInfo.getIndex() == Turn.LEFT_SHARP.ordinal() )
	        					priorityShare[outLink] = 2;
	        				else if (currentOutLinkInfo.getIndex() == Turn.RIGHT.ordinal() )
	        					priorityShare[outLink] = 3;
	        				else if (currentOutLinkInfo.getIndex() == Turn.LEFT.ordinal() )
	        					priorityShare[outLink] = 4;
	        				else 
	        					priorityShare[outLink] = 5;

							shareOfLanes[outLink] = ((double) inLanesAll.size() * currentOutLinkInfo.numberOfLanes) / numberOfLeavingLanes;
							ceilShareOfLanes[outLink] = (int) (Math.max(Math.ceil(shareOfLanes[outLink]), 1));
							exitLanes[outLink] = currentOutLinkInfo.numberOfLanes;
							if (ceilShareOfLanes[outLink] > exitLanes[outLink])
								ceilShareOfLanes[outLink] = (int) exitLanes[outLink];
							uTurn[outLink] = currentOutLinkInfo.isUTurn();
							sumCeil = sumCeil + ceilShareOfLanes[outLink];
        				}
    					
        				int indexFirst = 0;
        				int indexLast = numberOfLeavingLinks - 1;
        				int lanesToShare = sumCeil - numberOfTurnLanes;        						
    					
						// a shortage of lanes: either share lanes or less than demanded         					

    					if (sumCeil > numberOfTurnLanes  )  { 
    						// int lanesToShare = numberOfLeavingLinks - 1;
    						while (indexFirst < indexLast && lanesToShare > 0) {
        						if (priorityShare[indexFirst] <= priorityShare[indexFirst + 1]) {
        							// if the right-side movement has lower priority, than share lanes
        							if (priorityShare[indexFirst] <= priorityShare[indexLast] )  {
        								if (shareLaneNextMovement[indexFirst] == 0 && laneSharing) {
        									shareLaneNextMovement[indexFirst]++;
        								}
        								else
        									ceilShareOfLanes[indexFirst]--;
        								indexFirst++;
        							}
        							else  {
        								if (shareLaneNextMovement[indexLast] == 0 && laneSharing) {
        									shareLaneNextMovement[indexLast]++;
        								}
        								else
        									ceilShareOfLanes[indexLast]--;
        								indexLast--;
        							}
        						}
        						else if (priorityShare[indexFirst] > priorityShare[indexFirst + 1]) {
        							if (priorityShare[indexFirst + 1] < priorityShare[indexLast] )  {
        								if (shareLaneNextMovement[indexFirst + 1] == 0 && laneSharing) {
        									shareLaneNextMovement[indexFirst + 1]++;
        								}
        								else
        									if (ceilShareOfLanes[indexFirst + 1] > 1)
        										ceilShareOfLanes[indexFirst + 1]--;
        									else
        										shareLaneNextMovement[indexFirst]++;
        								indexFirst++;
        								indexFirst++;        								
        							}
        							else  {
        								if (shareLaneNextMovement[indexLast] == 0 && laneSharing) {
        									shareLaneNextMovement[indexLast - 1]++;
        								}
        								else {
        									if (ceilShareOfLanes[indexLast] > 1)
        										ceilShareOfLanes[indexLast]--;
        									else
        										shareLaneNextMovement[indexLast - 1]++;
        								}
        								indexLast--;
        							}
        						}
        						lanesToShare--;    						        						
    						}
    					}
    					// Strange junction or a merge!!
    					if (sumCeil < numberOfTurnLanes  )  {  
    						// int lanesToShare = numberOfLeavingLinks - 1;
    						while (lanesToShare < 0) {
    							mergeLanes++;
        						lanesToShare++;    						        						
    						}
    					}
    					
    					Lane currentInLane = null;
        				int indexCurrentInlane = 0;
    					for (int outLink = 0; outLink < numberOfLeavingLinks; outLink++)  {
    						OutLinkInfo currentOutLinkInfo = outLanesAndLinkList.get(outLink);
    						ArrayList<Lane> outLanes = currentOutLinkInfo.getOutLanes();
    						int outLaneIndex = 0;
    						//connect the in-coming and exiting lanes 
    						for (int i = 0; i < ceilShareOfLanes[outLink]; i++)  {
/*    							if (indexCurrentInlane == inLanesAll.size())
    								System.out.print("error junction");
    							
    							if (i == outLanes.size())
    								System.out.print("error junction");*/
    							currentInLane = inLanesAll.get(indexCurrentInlane);
					    		if (currentInLane.getStopLine() == null) {
					    			StopLine stopLine = new StopLine(currentInLane.getCse(), StopLine.NOSTOPLINE,-4.0, 2.0, 0.0); 
					    			currentInLane.setStopLine(stopLine);
					    		}
    							if (currentOutLinkInfo.isStartRight()) {						
	        						currentOutLane = outLanes.get(i);
	    						}
    							else {
	        						currentOutLane = outLanes.get(currentOutLinkInfo.numberOfLanes - ceilShareOfLanes[outLink] + i);
    							}
    							if (currentInLane == null)
    								System.out.print("no inlane??");
    							LaneConnect laneConnect = new LaneConnect(currentInLane, currentOutLane, outLink);
    							connectedLanesList.add(laneConnect);
    							// if there are more incoming lanes than leaving ones, connect all inlanes
    							if (mergeLanes > 0 && indexCurrentInlane == ceilShareOfLanes[outLink] - 1)  {
        							indexCurrentInlane++;
    								currentInLane = inLanesAll.get(indexCurrentInlane);
    					    		if (currentInLane.getStopLine() == null) {
    					    			StopLine stopLine = new StopLine(currentInLane.getCse(), StopLine.NOSTOPLINE,-4.0, 2.0, 0.0); 
    					    			currentInLane.setStopLine(stopLine);
    					    		}
        							laneConnect = new LaneConnect(currentInLane, currentOutLane, outLink);
        							connectedLanesList.add(laneConnect);
    							}
/*    							if (indexCurrentInlane < numberOfTurnLanes)
    								indexCurrentInlane++;*/
    							indexCurrentInlane++;
	    						outLaneIndex++;
    						}
    						// in case of any remaining exit lanes that are not yet connected
    						// i.e. if there are 2 right turning lanes and 3 exit lanes, 
    						// the second right lane (counting from outer to inner) here gets 
    						// connected to the third exit lane)
							for (int i = outLaneIndex; i < currentOutLinkInfo.numberOfLanes ; i++) {
								if (currentOutLinkInfo.isStartRight()) {
									currentOutLane = outLanes.get(i);
	    							if (currentInLane == null)
	    								System.out.print("no inlane??");

									LaneConnect laneConnect = new LaneConnect(currentInLane, currentOutLane, outLink);
									connectedLanesList.add(laneConnect);
								}
								else  {
/*	    							if (outLink == ceilShareOfLanes.length)
	    								System.out.print("error junction");
	    							if (indexCurrentInlane - ceilShareOfLanes[outLink] == inLanesAll.size())
	    								System.out.print("error junction");*/
	    							
									currentInLane = inLanesAll.get(indexCurrentInlane - ceilShareOfLanes[outLink]);
	    							if (currentInLane == null)
	    								System.out.print("no inlane??");

									currentOutLane = outLanes.get(currentOutLinkInfo.numberOfLanes - 1 - i);
									LaneConnect laneConnect = new LaneConnect(currentInLane, currentOutLane, outLink);
									connectedLanesList.add(0,laneConnect);
								}	
							}
							indexCurrentInlane = indexCurrentInlane - shareLaneNextMovement[outLink];
    					}
        				
	    			}   //FINISHED STEP 2B	
            	}
            		
            		
        		//STEP 3: create new turning links at the junction
				// every link can have one or more lanes
        		int laneIndex = 0;
				ArrayList<Lane> newLanes = new ArrayList<Lane>();
				Lane newLane = null;
				// when all incoming lanes are "inspected", the link and lane connectors are created
				// for every connection between an incoming and leaving arm, one link is created
				for (LaneConnect connectLanes : connectedLanesList) {
    				Lane currentOutLane = connectLanes.getOutLane();
    				Lane currentInLane = connectLanes.getInLane();
    				boolean sameOutLink = false;
    				if (!(currentInLane == null) && !(currentOutLane == null) ) {
    				//create a new lane that connect this incoming lane and this leaving lane		
	    				boolean addLink = false;
	    				// add a new link if...	
	    				if (laneIndex > 0)
	        				if (connectLanes.getLinkRank() != connectedLanesList.get(laneIndex-1).getLinkRank()) {
	    						addLink = true;
	    						sameOutLink = false;
	        				}
	        				else
	        					sameOutLink = true;
	    				
	    				if (addLink) {
	    			    	if (newLanes.size() == 0) 
	    			    		System.out.println("strange");
            				Link newLink = createJunctionLink(incoming, newLanes, rmaList);
            				newLinks.add(newLink);
		            		rmaList = new ArrayList<RoadMarkerAlong>();
							newLanes = new ArrayList<Lane>();
							addLink = false;
							newLanes.clear();
            			}
	    				boolean createCurve = false;
	    				Lane oldLane = null;
	    				if (newLanes.isEmpty())
	    					createCurve = true;
	    				if (newLane != null)
	    					oldLane = new Lane(newLane);
						newLane = newLaneConnection(currentInLane, currentOutLane, createCurve, oldLane, sameOutLink);	
						if (newLane.getID() == 17)
							System.out.println("Created lane " + newLane.getID());
	    				newLanes.add(0, newLane);
    				}
    				if (laneIndex == connectedLanesList.size() - 1) {
    			    	if (newLanes.size() == 0) 
    			    		System.out.println("strange");
        				Link newLink = createJunctionLink(incoming, newLanes, rmaList);
        				newLinks.add(newLink);
	            		rmaList = new ArrayList<RoadMarkerAlong>();
						newLanes = new ArrayList<Lane>();
						newLanes.clear();
    				}
    				laneIndex++;	
    			}
			}

			//Block B
			// revisit all new Turning Links at this node (junction) to investigate conflicting lanes (merge, split, cross)
			for (Link link : newLinks) {
				for (Link compareToLink : newLinks) {
					//only different links
					if (compareToLink == link)
						continue;
					// visit pairs of links only once
					if (compareToLink.getName_r().compareTo(link.getName_r()) <= 0)
						continue;
					PriorityConflict priorityConflict = null;
					conflictType cType = null;

					// After determining the type of conflict, the priority rules are applied (traffic from the right has priority)
					for (CrossSectionObject csoA : link.getCrossSections_r().get(0).getCrossSectionElementList_r().get(0).getCrossSectionObjects(Lane.class)) {
						for (CrossSectionObject csoB : compareToLink.getCrossSections_r().get(0).getCrossSectionElementList_r().get(0).getCrossSectionObjects(Lane.class)) {									
							if (null == csoA)
								System.err.println("fixLinkConnections: skipping null lane");
							else {
								cType = null;
								Lane laneA = (Lane) csoA;
								Lane laneB = (Lane) csoB;
								Lane priorityLane;// = null;//new Lane();
								Lane yieldLane;// = null;//new Lane();										

								Lane upA = laneA.getUp().get(0);
								Lane upB = laneB.getUp().get(0);
								Lane downA = laneA.getDown().get(0);
								Lane downB = laneB.getDown().get(0);
								Link linkUpA = upA.getCse().getCrossSection().getLink();
								Link linkUpB = upB.getCse().getCrossSection().getLink();
								Link linkDownA = downA.getCse().getCrossSection().getLink();
								Link linkDownB = downB.getCse().getCrossSection().getLink();
								boolean yieldA = true;
								boolean yieldB = true;
								
								if ((upA.getStopLine() != null) && (upA.getStopLine().getType() == StopLine.PRIORITYSTOPLINE))
									yieldA = false;								
								if ((upB.getStopLine() != null) && (upB.getStopLine().getType() == StopLine.PRIORITYSTOPLINE))
									yieldB = false;
								if (yieldA && (! yieldB)) {
									yieldLane = laneA;
									priorityLane = laneB;
								} else if ((! yieldA) && yieldB) {
									yieldLane = laneB;
									priorityLane = laneA;
								} else {	// Stop lines did not resolve this conflict.
									// Apply traffic law priority rules
									// could be on a junction with no rules or two opposing roads (both priority or yield)
									double angleIncomingA = Double.NaN;
									double angleIncomingB = Double.NaN;
									double angleLeavingA = Double.NaN;
									double angleLeavingB = Double.NaN;
									for (DirectionalLink incoming : dlList) {
										if (incoming.incoming) {
											if (incoming.link.equals(linkUpA))
												angleIncomingA = incoming.angle;
											else if (incoming.link.equals(linkUpB))
												angleIncomingB = incoming.angle;	
										} else {
											if (incoming.link.equals(linkDownA))
												angleLeavingA = incoming.angle;
											else if (incoming.link.equals(linkDownB))
												angleLeavingB = incoming.angle;
										}
									}
									double angleDif;
			            			if (angleIncomingA > angleIncomingB)
			            				angleDif = 2 * Math.PI - angleIncomingA + angleIncomingB;
			            			else
			            				angleDif = angleIncomingA - angleIncomingB;
									if (angleDif < 0.75 * Math.PI) {	// lane B comes from right
										yieldLane = laneA;
										priorityLane = laneB;
									} else if (angleDif > 1.25 * Math.PI) {	// lane B comes from left
										priorityLane = laneA;
										yieldLane = laneB;
									} else { // Opposing flows: turning movement determines priority rules
										double turnAngleA;
										double turnAngleB;
				            			if (angleIncomingA > angleLeavingA)
				            				turnAngleA = 2 * Math.PI - angleIncomingA + angleLeavingA;
				            			else
				            				turnAngleA = angleIncomingA - angleLeavingA;
				            			if (angleIncomingB > angleLeavingB)
				            				turnAngleB = 2 * Math.PI - angleIncomingB + angleLeavingB;
				            			else
				            				turnAngleB = angleIncomingB - angleLeavingB;
				            			// turn with smallest angle has priority
				            			if (turnAngleA < turnAngleB) {
											priorityLane = laneA;
											yieldLane = laneB;
				            			} else {
											yieldLane = laneA;
											priorityLane = laneB;
				            			}	
									}
								}
								StopLine stopLine = yieldLane.getUp().get(0).getStopLine();
								Polygon cArea = new Polygon();
								// Determine location at the lanes at the start of the conflict Area:
								Point2D.Double pInIn = getConflictIntersectionPoint(laneA.getLaneVerticesInner(), laneB.getLaneVerticesInner());
								Point2D.Double pInOut = getConflictIntersectionPoint(laneA.getLaneVerticesInner(), laneB.getLaneVerticesInner());
								Point2D.Double pOutIn = getConflictIntersectionPoint(laneA.getLaneVerticesInner(), laneB.getLaneVerticesInner());
								Point2D.Double pOutOut = getConflictIntersectionPoint(laneA.getLaneVerticesInner(), laneB.getLaneVerticesInner());
								// determine the stopLines of the incoming Link
								if (laneA.getUp().get(0).equals(laneB.getUp().get(0)))
									cType =  conflictType.SPLIT;
								//else if (link.getToNode_r().getPoint().equals(compareToLink.getToNode_r().getPoint())) 
								else if (laneA.getDown().get(0).equals(laneB.getDown().get(0)))
									cType =  conflictType.MERGE;
								else if ((pInIn != null) || (pInOut != null) || (pOutIn != null) || (pOutOut != null))
									cType = conflictType.CROSSING;

								Double cX = null;
								Double cY = null;
								if (pInIn != null) {
									cX = pInIn.getX();
									cY = pInIn.getY();
									cArea.addPoint(cX.intValue(), cY.intValue());
								}
								if (pInOut != null) {
									cX = pInOut.getX();
									cY = pInOut.getY();
									cArea.addPoint(cX.intValue(), cY.intValue());
								}
								if (pOutIn != null) {
									cX = pOutIn.getX();
									cY = pOutIn.getY();
									cArea.addPoint(cX.intValue(), cY.intValue());
								}
								if (pOutOut != null) {	
									cX = pOutOut.getX();
									cY = pOutOut.getY();
									cArea.addPoint(cX.intValue(), cY.intValue());
								}
								
								if (conflictType.MERGE == cType || conflictType.CROSSING == cType)  {
									if (cType.equals(conflictType.MERGE))
										yieldLane.addMergingYieldToLaneList(priorityLane);
									else if (cType.equals(conflictType.CROSSING))
										yieldLane.addCrossingYieldToLaneList(priorityLane);
									priorityConflict = new PriorityConflict(priorityLane, yieldLane, cType, cArea);
									//  add conflict to the relevant stopLine 
									if (stopLine == null)		
										System.err.println("no Stopline created or found");
									else
										stopLine.addConflicts(priorityConflict);
								} else {
									System.out.println(String.format("Conflict of y%s and p%s at node %d has no intersection...", yieldLane.toString(), priorityLane.toString(), nodeID));
								}
							}
						}
					}
				}
			}
			System.out.format("Adding %d links to network for node %s\n", newLinks.size(), name);
		}
		
    }

    private static Point2D.Double getConflictIntersectionPoint(ArrayList<Vertex> verticesA, ArrayList<Vertex> verticesB)   {
		Vertex prevA = null;
		for (Vertex vA : verticesA)  {
			if (! (prevA == null)) {
				Line2D.Double lineA = new Line2D.Double(prevA.getX(),prevA.getY(),vA.getX(),vA.getY());
				Vertex prevB = null;
				for (Vertex vB : verticesB) {
					if (! (prevB == null))   {
						Line2D.Double lineB = new Line2D.Double(prevB.getX(),prevB.getY(),vB.getX(),vB.getY());
						if (Planar.lineSegmentIntersectsLineSegment(lineA, lineB))
							return Planar.intersection(lineA,  lineB);
					}
					prevB = vB;
				}
			}
			prevA = vA;												
		}
		return null;
    }
    
    private static Lane newLaneConnection(Lane upLane, Lane downLane, boolean createCurve, Lane oldLane, boolean sameOutlink) {
		// create a new lane that connects the in and outgoing lane 
		double laneWidth = downLane.getWidth();
		Lane newLane = new Lane(null, null, null, 0, laneWidth, Lane.NOORIGIN, Lane.NODESTINATION);
		newLane.addDownLane(downLane);
		newLane.addUpLane(upLane);							
		downLane.addUpLane(newLane);
		upLane.addDownLane(newLane);
		if (null == upLane.getLaneVerticesCenter()) {
			System.err.println("newLaneConnection: linkPointList is null");
			upLane.getLaneVerticesCenter();
			return null;
		}
		if (null == downLane.getLaneVerticesCenter()) {
			System.err.println("newLaneConnection: linkPointList is null");
			return null;
		}
		if (createCurve) {
			ArrayList<Vertex> up = upLane.getLaneVerticesCenter();
			ArrayList<Vertex> down = downLane.getLaneVerticesCenter();
			if ((up.size() == 0) || (down.size() == 0))
				System.err.println("Oops: up.size is " + up.size() + ", down.size is " + down.size());
			Point2D.Double ctrlPoint = Curves.createControlPoint(up, down);
			newLane.setCtrlPointCenter(ctrlPoint);
			ArrayList<Vertex> laneVerticesCenter = new ArrayList<Vertex>();
			if (ctrlPoint == null)
				System.out.println("stop");
			laneVerticesCenter = Curves.connectVerticesCurve(up, down, ctrlPoint, 0.3);
			// laneVerticesCenter.get(0).setPoint(up.get(up.size()-1).getX(), up.get(up.size()-1).getY(), up.get(up.size()-1).getZ());
			// laneVerticesCenter.get(laneVerticesCenter.size()-1).setPoint(down.get(0).getX(), down.get(0).getY(), down.get(0).getZ());
			newLane.setDesignLine(laneVerticesCenter);			
			newLane.setLaneVerticesInner(Planar.createParallelVertices(laneVerticesCenter, - newLane.getLateralWidth() / 2));
			newLane.setLaneVerticesOuter(Planar.createParallelVertices(laneVerticesCenter, + newLane.getLateralWidth() / 2));
		} else {
			boolean sameUp = false;
			boolean sameDown = false;
			ArrayList<Vertex> laneVerticesCenter = new ArrayList<Vertex>();
			ArrayList<Vertex> prevLaneVerticesCenter = oldLane.getUp().get(0).getLaneVerticesCenter();
			Vertex oldUp = prevLaneVerticesCenter.get(prevLaneVerticesCenter.size()-1);
			prevLaneVerticesCenter = oldLane.getDown().get(0).getLaneVerticesCenter();
			Vertex oldDown = prevLaneVerticesCenter.get(0);
			Vertex up = upLane.getLaneVerticesCenter().get(upLane.getLaneVerticesCenter().size()-1);
			Vertex down = downLane.getLaneVerticesCenter().get(0);		
			
			if (up.equals(oldUp)  && sameOutlink)
				sameUp = true;
			if (down.equals(oldDown))
				sameDown = true;
			// create parallel vertices
			prevLaneVerticesCenter = oldLane.getLaneVerticesCenter();
			laneVerticesCenter = Planar.createParallelVertices(prevLaneVerticesCenter, -oldLane.getLateralWidth());
			// if same upLane: create weighted vertices in between
			if (sameUp == true)
				laneVerticesCenter = Planar.createPartlyParallelVertices(prevLaneVerticesCenter, laneVerticesCenter, sameUp, sameDown);
			newLane.setDesignLine(laneVerticesCenter);
			newLane.setLaneVerticesInner(Planar.createParallelVertices(laneVerticesCenter, - newLane.getLateralWidth() / 2));
			newLane.setLaneVerticesOuter(Planar.createParallelVertices(laneVerticesCenter, + newLane.getLateralWidth() / 2));
		}
		return newLane;   	
    }
    
    /**
     * Create a {@link Link} at a junction (turning movements).
     * @param currentInLane
     * @param currentOutLane
     * @param incoming
     * @param newLanes
     * @param rmaList
     * @return {@link Link}; the newly created Link
     */
    private Link createJunctionLink(DirectionalLink incoming, ArrayList<Lane> newLanes, ArrayList<RoadMarkerAlong> rmaList)  { 
		CrossSectionElement inCse = newLanes.get(0).getUp().get(0).getCse();
		Node expandNode1 = expandNode(true, incoming.link, inCse);
		CrossSectionElement outCse = newLanes.get(0).getDown().get(0).getCse();
		Link outLink = outCse.getCrossSection().getLink();
		Node expandNode2 = expandNode(false, outLink, outCse);
		ArrayList<CrossSectionElement> cseList = new ArrayList<CrossSectionElement>();
		CrossSection newCs = new CrossSection(0, 0, cseList);
		
		double width = 0.0;
		String typeContinuous = RoadMarkerAlongTemplate.ALONG_CONTINUOUS;
		String typeStriped = RoadMarkerAlongTemplate.ALONG_STRIPED;
		RoadMarkerAlong rma = null;
		int count = 0;
		Lane prev = null;
		ArrayList<Vertex> tempVertices = new ArrayList<Vertex>(); 
		for (Lane lane : newLanes)  {
			if (null == lane) {
				System.err.println("createJunctionLink: Skipping null lane");
				// TODO figure out if this still happens and fix it
				continue;
			}
			if (count == 0)
				rma = new RoadMarkerAlong(typeContinuous, width);
			else
				rma = new RoadMarkerAlong(typeStriped, width);
			rma.setVertices(lane.getLaneVerticesInner());
			count++;
			rmaList.add(rma);
			width += lane.getLateralWidth();
			if (prev != null)  {
				lane.setLeft(prev);
				prev.setRight(lane);
				if (rma.getType() == typeStriped) {
					lane.setGoLeft(true);
					prev.setGoRight(true);
				}				
			}
			prev = lane;
			tempVertices = lane.getLaneVerticesOuter();
		}
		// closing roadMarkerAlong 
		rma = new RoadMarkerAlong(typeContinuous, width);
		rma.setVertices(tempVertices);
		rmaList.add(rma);		
		CrossSectionElement newCse = new CrossSectionElement(newCs, "road", width, rmaList, null);
		
		ArrayList<Vertex> vertexInner = rmaList.get(0).getVertices();
		newCse.setVertices(rmaList.get(0).getVertices(), tempVertices);
		for (Lane lane : newLanes) {
			newCse.addCrossSectionObject(lane);
			lane.setCse(newCse);
		}
		cseList.add(newCse);
		ArrayList<CrossSection> csList = new ArrayList<CrossSection>();
		csList.add(newCs);
		// Generate a unique name for the new link that makes some sense
		String linkName = "_" + expandNode1.nodeID + "_" + expandNode2.nodeID + "_";
		for (int i = 1; ; i++)
			if (null == network.lookupLink(linkName + i)) {
				linkName += i;
				break;
			}
		Link newLink = network.addLink(linkName, expandNode1.nodeID, expandNode2.nodeID, 0, false, csList,  vertexInner);
		newCs.setLink(newLink);
		newLink.setFromNodeExpand(expandNode1);
		newLink.setToNodeExpand(expandNode2);
		newLink.setAutoGenerated(true);
		// if there are parallel lanes for a turn, provide the left and right info
		return newLink;
    }
 
    /**
     * Return a caption for the pop up menu of the {@link nl.tudelft.otsim.GUI.ObjectInspector}.
     * @return String; caption for the pop up menu of the {@link nl.tudelft.otsim.GUI.ObjectInspector}
     */
    @SuppressWarnings("static-method")
	public String itemizeTrafficLightController_caption() {
    	return "Traffic light controller";
    }
    
    /**
     * We need this one too for the caption of the pop up menu of the 
     * {@link nl.tudelft.otsim.GUI.ObjectInspector}.
     * @return String; caption for the pop up menu of the {@link nl.tudelft.otsim.GUI.ObjectInspector}
     */
    public String getTrafficLightController_r() {
     	return "Click twice to create, edit, or remove a Traffic light controller at node " + name;
    }
    
    private static final String addTrafficLightController = "Create a traffic light controller at node ";
    private static final String editTrafficLightController = "Edit the traffic light controller at node ";
    private static final String deleteTrafficLightController = "Delete the traffic light controller at node ";
    
    /**
     * Create or remove a {@link TrafficLightController} at this Node.
     * @param object Object; should be a String
     */
    public void setTrafficLightController_w (Object object) {
    	System.out.println("setTrafficLightController_w called; object is " + object.toString());
    	if (object instanceof String) {
    		String value = (String) object;
    		if (value.startsWith(addTrafficLightController))
    			this.trafficLightController = new TrafficLightController(network, "TL_" + name);
    		else if (value.startsWith(editTrafficLightController))
    			network.openObjectInspector(trafficLightController);
    		else if (value.startsWith(deleteTrafficLightController)) {
    			trafficLightController.deleteAllLightsAndDetectors();
    			trafficLightController = null;
    		} else
    			throw new Error("setTrafficLightController does not know what \"" + value + "\" means");
    	} else
    		throw new Error("setTrafficLightController should be called with a String object");
    }
    
    /**
     * Return a list of items for the pop up menu of the
     * {@link nl.tudelft.otsim.GUI.ObjectInspector}.
     * @return ArrayList&lt;String&gt;; the list of one item for the pop up
     * menu of the {@link nl.tudelft.otsim.GUI.ObjectInspector}
     */
    public ArrayList<String> itemizeTrafficLightController_i() {
    	ArrayList<String> result = new ArrayList<String>();
    	if (null == trafficLightController)
    		result.add(addTrafficLightController + name);
    	else {
    		result.add(editTrafficLightController + name);
    		result.add(deleteTrafficLightController + name);
    	}
    	return result;
    }
    
    private Node expandNode(boolean in, Link link, CrossSectionElement inCse) {
    	Node expandedNode = null;
    	if ((in && (link.getToNodeExpand() == link.getToNode_r())) || 
    			((!in) && (link.getFromNodeExpand() == link.getFromNode_r()))) {
    		// Node is not (yet) expanded for this link; create an extra node
			String nodeName = "" + link.getFromNode_r().getNodeID() + "_" + link.getToNode_r().getNodeID();
			// TODO: rewrite this using vertexFromNode
			ArrayList<Vertex> linkPointList = inCse.createAndCleanLinkPointListInner(true, true, false);
			if (linkPointList.size() < 1) {
				System.err.println("expandNode: linkPointList is too short");
				return null;	// TODO figure out if this is fatal further down the road
			}
			//System.out.format("expandNode: inserting extra node %s between nodes %s and %s\r\n", 
			//		nodeName, link.getFromNode_r().getName_r(), link.getToNode_r().getName_r());
			Vertex v = linkPointList.get(in ? linkPointList.size() - 1 : 0);
			expandedNode = new Node(network, nodeName, network.nextNodeID(), v.x, v.y, v.z, true);
			network.addExpandedNode(expandedNode);
			// Connect the Link to the newly created Node
			if (in)
				link.setToNodeExpand(expandedNode);
			else
				link.setFromNodeExpand(expandedNode);
	    } else if (in)	// incoming link and node is already expanded
			expandedNode = link.getToNodeExpand();
		else			// outgoing link and node is already expanded
			expandedNode = link.getFromNodeExpand();
		return expandedNode;
    }
    
    /**
     * Create a GeneralPath that describes the conflictArea of this Node.
     * @return GeneralPath; the contour of the conflictArea of this Node
     */
	public GeneralPath createJunctionPolygon()   {
		GeneralPath polygon = new GeneralPath(Path2D.WIND_EVEN_ODD);
		boolean firstPoint = true;
		for (Vertex v : conflictArea)  {
			if (firstPoint)
				polygon.moveTo(v.getX(), v.getY());
			else
				polygon.lineTo(v.getX(), v.getY());
			firstPoint = false;
		}
		polygon.closePath();
		return polygon;
	}
    
    /**
     * Draw this Node on a GraphicsPanel.
     * @param graphicsPanel GraphicsPanel; graphicsPanel to draw onto
     */
	@Override
	public void paint(GraphicsPanel graphicsPanel) {
        final int nonSelectedNodeDiameter = 6;
        final int selectedNodeDiameter = 20;

    	Point2D.Double point = getPoint();            
    	graphicsPanel.setStroke(1F);
        final Color color = network.isExpandedNode(this) ? Color.blue : Color.RED;
        graphicsPanel.setColor(color);
        if ((! network.isExpandedNode(this)) || (Main.mainFrame.showLabelsOnAutogeneratedNodes.isSelected()))
        	graphicsPanel.drawString(getName_r(), point);
        graphicsPanel.setStroke(0f);
        graphicsPanel.drawCircle(point, color, nonSelectedNodeDiameter);
        graphicsPanel.setStroke(6f);
    	if (network.selectedMicroZone != null)  {
        	for (Integer nodeNumber : network.selectedMicroZone.getNodeList()) {
				Node node = network.lookupNode(nodeNumber, true);
				if (this == node)
					graphicsPanel.drawCircle(point, Color.BLUE, selectedNodeDiameter);
        	}
    	}
        if ((null != network.startNode) && (getNodeID() == network.startNode.getNodeID()))
        	graphicsPanel.drawCircle(point, Color.RED, selectedNodeDiameter);
        if ((null != network.endNode) && (getNodeID() == network.endNode.getNodeID()))
        	graphicsPanel.drawCircle(point, Color.PINK, selectedNodeDiameter);
        if (null != conflictArea) {
        	graphicsPanel.setStroke(0F);
        	graphicsPanel.setColor(Color.CYAN);
        	graphicsPanel.drawPolyLine(conflictArea);
        }
        if (null != circle) {
        	graphicsPanel.setStroke(0F);
        	double r = graphicsPanel.translate(new Point2D.Double(circle.radius(), 0)).distance(graphicsPanel.translate(new Point2D.Double(0, 0)));
        	graphicsPanel.drawCircle(circle.center(), Color.CYAN, (int) (2 * r));
        }
	}

	/**
	 * Retrieve the {@link TrafficLightController} of this Node
	 * @return {@link TrafficLightController}; the TrafficLightController of
	 * this Node, or null if this Node does not have a TrafficLightController
	 */
	public TrafficLightController getTrafficLightController() {
		return trafficLightController;
	}

	/**
	 * Retrieve the lines needed to make the drive-able boundaries of this node <i>water tight</i>.
	 * @return String; the textual description of the closing lines at this Node
	 */
	public String getClosingLines() {
		String result = "";
		for (ArrayList<Vertex> alv : closingLines) {
			result += "Border\t";
			for (Vertex v : alv)
				result += String.format(Locale.US, "%.2f\t%.2f\t", v.getX(), v.getY());
        	result += "\n";
		}
		return result;
	}

	/**
	 * Determine if this Node has a conflict area.
	 * @return Boolean; true if this Node has a real conflict area; false if 
	 * this Node does not have a real conflict area
	 */
	public boolean hasConflictArea() {
		return (null != conflictArea) && (conflictArea.size() > 0);
	}

	/**
	 * Return whether this node was created in Junction Expansion.
	 * @return Boolean; true if this node was created in Junction Expansion; false otherwise
	 */
	public boolean isAutoGenerated() {
		return autoGenerated;
	}

}
